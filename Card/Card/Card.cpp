// Card.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"


//
//  main.cpp
//  card
//
//  Created by admin on 13-11-19.
//  Copyright (c) 2013年 admin. All rights reserved.
//

#include <iostream>
#include <list>
#include <vector>
using namespace std;
#define MAKENODE(A,B,C)  (A<<16 || B <<8 || C)

#define NODE1(N)  (0x0000000000001111b & N)
#define NODE2(N)  (0x0000000011110000b & N)
#define NODE3(N)  (0x0000111100000000b & N)

#define CARDNUM   21
 

#define NODEN(N,deep) (0x0F <<((deep-1)*4))

int TakeShe(char*);
int TakeKan(char*);

//用来表示每一种牌和可以结合的拍的数组
char REL[CARDNUM][CARDNUM]={
	{0},
	{4,1,2,3,11},       //xiao 1
	{6,2,3,4,7,10,12},  //xiao 2
	{4,3,4,5,13},       //xiao 3
	{4,4,5,6,14},       //xiao 4
	{4,5,6,7,15},       //xiao 5
	{4,6,7,8,16},       //xiao 6
	{5,7,8,9,10,17},    //xiao 7
	{4,8,9,10,18},      //xiao 8
	{3,9,10,19},        //xiao 9
	{2,10,20},
	{3,11,12,13},       //da 1
	{3,12,13,14,17,20},
	{3,13,14,15},       //da 3
	{3,14,15,16},
	{3,15,16,17},       //da 5
	{3,16,17,18},
	{3,17,18,19,20},    //da 7
	{3,18,19,20},
	{2,19,20},
	{1,20}
};

//表示每种牌的两两之间的结合性
char CanPatchList[CARDNUM][CARDNUM]={
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},//xiao 3
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},//xiao7
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},//xiao10
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},//da 2
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},//da 5
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},// da7
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1},//da 9
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1-1,-1}//da 10

};

//描述我的牌的情况的多叉树
typedef int CARDTYPE;
typedef struct Node
{
	CARDTYPE val;
	vector<Node *> children;
}CardTree;

CardTree my_tree;

//描述每个人手上的一张牌
char my_card[21]={0,2,2,2,0,1,1,1,0,0,2,0,1,1,0,0,0,0,0,0,1};


int f0(int pnode,char * Card,int deep){

	if(deep==3){

		return 0;
	}
	my_tree.val = pnode;
	my_tree.children.size();
	for(int i = 1 ; i <  CARDNUM ; i++){

		if(my_card[i]>0){
			//便利所有的可以结合的牌是否在my_card里面

			my_card[i]--;//减去本张牌

			for (int k =1,num=REL[i][0]; k<num; k++) {

				if (  my_card[k] > 0) {

					f0(MAKENODE(),Card,deep+1);

				}


			}

			my_card[i]++;




		}

	}


}

int main(int argc, const char * argv[])
{

	// insert code here...
	std::cout << "Hello, World!\n";
	return 0;
}



//去掉蛇
int TakeShe(char * CARD){

	for (int i = 1; i< CARDNUM; i++) {
		if(CARD[i]>=4){
			return i;
		}
	}
}

//去掉坎
int TakeKan(char * CARD){

	for (int i = 1; i< CARDNUM; i++) {
		if(CARD[i]==3){
			return i;
		}
	}
}

